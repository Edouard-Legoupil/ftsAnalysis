# WARNING - Generated by {fusen} from dev/flat_dev_4_analysis.Rmd: do not edit by hand # nolint: line_length_linter.

#' Aggregate historical amounts by month and forecast future funding for a donor or recipient.
#'
#' @param flows Dataframe `flows`.
#' @param by Character: "donor" or "recipient" (which entity to forecast for).
#' @param name Character: name of donor or recipient to forecast.
#' @param h Integer: months to forecast ahead (default 12).
#'
#' @return A list with components: ts (monthly ts), model (fitted ARIMA), forecast (forecast object)
#' @importFrom tidyr unnest
#' @importFrom dplyr filter mutate group_by summarise arrange if_else
#' @importFrom lubridate ymd floor_date ymd_hms
#' @importFrom forecast auto.arima forecast
#' @export
#' @examples
#' donor <- "Germany"
#' forecast_result <- analysis_funding_forecast(flows,
#'                                              by = "donor", 
#'                                              name = donor)
#'
#' ggplot2::autoplot(forecast_result$forecast) +
#'
#'   ggplot2::scale_y_continuous(labels = scales::label_number(
#'     scale_cut = scales::cut_short_scale())) +
#'   ggplot2::labs(title = paste0("Funding Forecast of monthly funding amounts from ",
#'   donor),
#'        subtitle= "Using an Autoregressive Integrated Moving Average time
#'        series model (ARIMA).",
#'        x = "Year",
#'        y = "Funding Amount (USD)",
#'        caption = paste0(
#'     "Indicator interpretation:",
#'     "The **dark line** represents the historical monthly funding data used for
#'     training the model. The **lighter line** extending to the right shows
#'     the **future forecast**.",
#'     "\n\n",
#'     
#'     "The **shaded areas** surrounding the forecast line represent 
#'     the **prediction intervals**: the **darker shade** is the 80% confidence 
#'     interval, and the **lighter shade** is the 95% confidence interval. 
#'     These areas indicate the likely range of future funding, showing the
#'     uncertainty inherent in the forecast: the wider the shade, 
#'     the less certain the prediction.",
#'     "\n\n",
#'     "**Data Source**: OCHA Financial Tracking Service (FTS) API.")) +
#'   unhcrthemes::theme_unhcr(grid = TRUE, 
#'                            axis =  FALSE, 
#'                            axis_title = FALSE,
#'                            legend=TRUE)  
analysis_funding_forecast <- function(flows, by = c("donor", "recipient"), name, h = 12) {
  by <- match.arg(by)
  
  # --- 1. Prepare Base Data: Unnest and Rename ---
  df <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::rename(donor = sourceObjects_name, donor_type = sourceObjects_type) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(recipient = destinationObjects_name, dest_type = destinationObjects_type) |>
    dplyr::mutate(amountUSD = as.numeric(amountUSD))
  
  # --- 2. Filter and Aggregate by Entity ---
  if (by == "donor") {
    sel <- df |>
      dplyr::filter(donor == name)
    if (nrow(sel) == 0) stop("No flows found for donor ", name)
    
    sel <- sel |>
      dplyr::mutate(
        # Attempt to parse date/time fields first
        dt_hms = suppressWarnings(lubridate::ymd_hms(date)),
        dt_ymd = suppressWarnings(lubridate::ymd(date)),
        # FIX: Use dplyr::if_else to prevent date/time coercion to numeric
        dt = dplyr::if_else(
          !is.na(dt_hms), 
          dt_hms, 
          as.POSIXct(dt_ymd) # Ensure final column is consistent POSIXct
        ),
        month = as.Date(lubridate::floor_date(dt, unit = "month"))
      ) |>
      dplyr::group_by(month) |>
      dplyr::summarise(amount = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
      dplyr::arrange(month)
      
  } else { # by == "recipient"
    sel <- df |>
      dplyr::filter(recipient == name)
    if (nrow(sel) == 0) stop("No flows found for recipient ", name)
    
    sel <- sel |>
      dplyr::mutate(
        # Attempt to parse date/time fields first
        dt_hms = suppressWarnings(lubridate::ymd_hms(date)),
        dt_ymd = suppressWarnings(lubridate::ymd(date)),
        # FIX: Use dplyr::if_else to prevent date/time coercion to numeric
        dt = dplyr::if_else(
          !is.na(dt_hms), 
          dt_hms, 
          as.POSIXct(dt_ymd) # Ensure final column is consistent POSIXct
        ),
        month = as.Date(lubridate::floor_date(dt, unit = "month"))
      ) |>
      dplyr::group_by(month) |>
      dplyr::summarise(amount = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
      dplyr::arrange(month)
  }
  
  # --- 3. Forecast ---
  
  # ensure continuous monthly series
  if (nrow(sel) < 2) stop("Not enough monthly observations to build a forecast.")
  
  # Find start year and month for the ts object
  ts_start <- c(as.integer(format(min(sel$month), "%Y")), 
                as.integer(format(min(sel$month), "%m")))
                
  ts_vec <- stats::ts(sel$amount, start = ts_start, frequency = 12)
  
  # Handle potential issues with too few data points for auto.arima
  if (length(ts_vec) < 24) {
      warning("Time series is short. auto.arima might struggle to identify seasonal patterns.")
  }

  fit <- forecast::auto.arima(ts_vec)
  fcast <- forecast::forecast(fit, h = h)
  
  return(list(ts = ts_vec, model = fit, forecast = fcast))
}
