# WARNING - Generated by {fusen} from dev/flat_dev_2_indicator.Rmd: do not edit by hand # nolint: line_length_linter.

#' Donors Systemic: Destination Alignment (Optimized)
#'
#' Calculates pairwise Jaccard similarity between donors based on their funded
#' destinations (locations or clusters). This indicates overlap or convergence
#' in geographic or thematic focus.
#'
#' Goal: Measures how many destinations are common between donors relative to
#' their total unique destinations, producing a 0–1 index.
#'
#' @details
#' The function works as follows:
#' \enumerate{
#'   \item Filters flows using `filter_flows_for_indicators()` to remove flows
#'         that should not be included (e.g., parked parents, pass-throughs,
#'         out-of-boundary flows).
#'   \item Unnests `sourceObjects` and `destinationObjects`, keeping only
#'         donors and valid destination types 
#'         (`Cluster`, `GlobalCluster`, `Location`).
#'   \item Creates a list of destinations for each donor.
#'   \item Computes Jaccard similarity between all unique donor pairs using
#'         precomputed lists, avoiding repeated filtering.
#'   \item Returns a tibble with `donor1`, `donor2`, and `Destination_Alignment`.
#' }
#'
#' @param flows A dataframe including at least `sourceObjects` and
#'        `destinationObjects` as nested data frames.
#'
#' @return A tibble with columns:
#' \describe{
#'   \item{donor1}{First donor in the pair.}
#'   \item{donor2}{Second donor in the pair.}
#'   \item{Destination_Alignment}{Jaccard similarity (0–1) of destinations.}
#' }
#'
#' @importFrom dplyr select filter rename group_by summarise distinct bind_rows
#' @importFrom tidyr unnest
#' @importFrom purrr map_dfr
#' @export
#' @examples
#'
#' # Compute alignment
#' alignment <- indicator_cross_donor_systemic_destination_alignment(flows)
#'
#' # Viz
#' library(ggplot2)
#' library(dplyr)
#'
#'
#' # Compute total funding per donor
#' top_donors <- flows |>
#'   tidyr::unnest(sourceObjects, names_sep = "_") |>
#'   dplyr::filter(sourceObjects_type == "Organization") |>
#'   dplyr::rename(donor = sourceObjects_name) |>
#'   dplyr::group_by(donor) |>
#'   dplyr::summarise(total_funding = sum(amountUSD, na.rm = TRUE),
#'                    .groups = "drop") |>
#'   dplyr::arrange(desc(total_funding)) |>
#'   dplyr::slice_head(n = 15) |>
#'   dplyr::pull(donor)
#'
#' # Filter alignment to top donors
#' alignment_top <- alignment |>
#'   dplyr::filter(donor1 %in% top_donors, donor2 %in% top_donors) |>
#'     dplyr::mutate(
#'       donor1 = stringr::str_wrap(donor1, width = 40),
#'       donor2 = stringr::str_wrap(donor2, width = 40)
#'     )
#'
#' # Prepare data for ggplot
#' plot_df <- alignment_top |>
#'   dplyr::mutate(
#'     donor1 = factor(donor1),
#'     donor2 = factor(donor2)
#'   )
#'
#' # Heatmap
#' ggplot(plot_df, aes(x = donor2, y = donor1, fill = Destination_Alignment)) +
#'   geom_tile(color = "white") +
#'   scale_fill_viridis_c(option = "plasma", na.value = "grey80", limits = c(0, 1)) +
#'   unhcrthemes::theme_unhcr(grid = FALSE, axis =  FALSE, axis_title = FALSE, legend=TRUE) +
#'   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#'   labs(
#'     title = "Top 15 Donors to Destination Alignment",
#'     x = "Donor 2",
#'     y = "Donor 1",
#'     fill = "Jaccard\nSimilarity",
#'     caption = paste(
#'     "Indicator interpretation:",
#'     "Jaccard similarity measuring overlap in funded locations/clusters 
#'     between donor pairs (0 = no overlap, 1 = identical destination portfolios).",
#'     "\n\n",
#'     
#'     "How to read the visualization:",
#'     "Heatmap shows pairwise alignment. Dark colors indicate high 
#'     geographic/thematic overlap, light colors indicate complementary coverage.",
#'     "\n\n",
#'     
#'     "Humanitarian relevance:",
#'     "Identifies donor clusters with similar focus areas, helping coordinate 
#'     advocacy and avoid duplication in under-funded crises.", "\n\n",
#'     
#'     "Source: Financial Tracking Service (FTS) API."
#'   )
#'   )
#'
indicator_cross_donor_systemic_destination_alignment <- function(flows) {
  
  flows <- filter_flows_for_indicators(flows)
  
  # Unnest and filter donors + destinations
  df <- flows |>
    dplyr::select(sourceObjects, destinationObjects) |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::filter(destinationObjects_type %in% c( "Location")) |>
    dplyr::rename(destination = destinationObjects_name) |>
    dplyr::distinct(donor, destination)
  
  # Create list of destinations per donor
  donor_dest <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(dest_list = list(destination), .groups = "drop")
  
  donors <- donor_dest$donor
  
  # Compute Jaccard similarity using precomputed lists
  res <- combn(donors, 2, simplify = FALSE) |>
    purrr::map_dfr(function(pair) {
      d1 <- donor_dest$dest_list[[which(donor_dest$donor == pair[1])]]
      d2 <- donor_dest$dest_list[[which(donor_dest$donor == pair[2])]]
      inter <- length(intersect(d1, d2))
      union <- length(union(d1, d2))
      tibble::tibble(
        donor1 = pair[1],
        donor2 = pair[2],
        Destination_Alignment = ifelse(union == 0, NA_real_, inter / union)
      )
    })
  
  # Mirror the pairs to get full donor×donor table
  full_res <- dplyr::bind_rows(res, res |> dplyr::rename(donor1 = donor2,
                                                         donor2 = donor1))
  
  # Optionally, diagonal = 1
  diagonal <- tibble::tibble(donor1 = donors, donor2 = donors, 
                             Destination_Alignment = 1)
  
  final_res <- dplyr::bind_rows(full_res, diagonal)
  
  
  return(final_res)
}
