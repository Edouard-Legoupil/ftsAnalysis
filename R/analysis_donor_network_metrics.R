# WARNING - Generated by {fusen} from dev/flat_dev_4_analysis.Rmd: do not edit by hand # nolint: line_length_linter.

#' Donor-Destination Network Metrics 
#'
#' Builds a bipartite donor -> destination network from flows, filtered to include
#' only flows directed to the specified `recipient_name`. Computes node centrality measures
#' (degree, betweenness, eigenvector) for the involved donors and destinations.
#'
#' @param flows Dataframe `flows`.
#' @param recipient_name Character: The name of the specific
#'            recipient/destination to analyze.
#' @param top_n Optional integer: restricts the network to top_n donors
#'              and top_n destinations
#'   by amount *within the filtered flows* for readability.
#'
#' @return A list with components: graph (igraph object), 
#'    donor_metrics (tibble), destination_metrics (tibble)
#' @importFrom tidyr unnest
#' @importFrom dplyr group_by summarise arrange desc slice_head pull mutate filter rename
#' @importFrom igraph graph_from_data_frame degree betweenness eigen_centrality V
#' @export
#' @examples
#' result <- analysis_donor_network_metrics(flows,
#'                recipient_name = "United Nations High Commissioner for Refugees")
#' print(result$plot)
analysis_donor_network_metrics <- function(flows, 
                                           recipient_name = NULL, 
                                           top_n = 20) {
  
  flows <- filter_flows_for_indicators(flows)
  # --- 1. Prepare Base Data (Donor -> Destination) ---
  df <- flows |>
    dplyr::mutate(destinationObjects2 = destinationObjects) |>
    tidyr::unnest(destinationObjects,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(destinationObjects_type == "Location") |>
    dplyr::rename(destination = destinationObjects_name) |>
    tidyr::unnest(sourceObjects,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects2,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(destinationObjects2_type == "Organization")|>
    dplyr::mutate(amountUSD = as.numeric(amountUSD))|>
    dplyr::rename(recipient = destinationObjects2_name) 
  
  # --- 2. Filter by Recipient Name (NEW STEP) ---
  # If recipient_name is provided, filter the flows.
  # Note: The original 'recipient' column name is now 'destination'.
  if (!is.null(recipient_name)) {
    df <- df |>
      dplyr::filter(recipient == recipient_name)
    
    if (nrow(df) == 0) {
      warning("No flows found for the specified recipient/destination: ", recipient_name)
      return(list(graph = NULL, donor_metrics = NULL, destination_metrics = NULL))
    }
    
    # If filtered to one destination, we don't need 'top_n' for destinations, 
    # but we still calculate donor metrics based on the filtered edges.
  }
  
  # --- 3. Restrict by Top N (Donor and Destination) ---
  
  # Top Donors based on total amount *in the filtered data*
  donors_top <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(total = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(total)) |>
    dplyr::slice_head(n = top_n) |>
    dplyr::pull(donor)
  
  # Top Destinations (Recipient) based on total amount *in the filtered data*
  # If recipient_name was provided, this list will likely just contain that name, 
  # or the top N if no name was specified.
  destinations_top <- df |>
    dplyr::group_by(destination) |>
    dplyr::summarise(total = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(total)) |>
    dplyr::slice_head(n = top_n) |>
    dplyr::pull(destination)
  
  # --- 4. Build Edges and Graph ---
  edges <- df |>
    dplyr::filter(donor %in% donors_top, destination %in% destinations_top) |>
    dplyr::group_by(donor, destination) |>
    dplyr::summarise(weight = sum(amountUSD, na.rm = TRUE), .groups = "drop")
  
  g <- igraph::graph_from_data_frame(edges, directed = FALSE)
  
  # --- 5. Compute Donor Metrics ---
  # Note: Must ensure nodes exist in the graph before calculating metrics
  donors_nodes <- intersect(igraph::V(g)$name, donors_top)
  
  donor_deg <- igraph::degree(g, v = donors_nodes)
  donor_betw <- igraph::betweenness(g, v = donors_nodes)
  # eigen_centrality requires a complex match because igraph returns a named vector
  donor_eig_vector <- igraph::eigen_centrality(g, directed = FALSE)$vector
  donor_eig <- donor_eig_vector[match(donors_nodes, names(donor_eig_vector))]
  
  donor_metrics <- tibble::tibble(
    donor = donors_nodes,
    degree = donor_deg,
    betweenness = donor_betw,
    eigen_centrality = donor_eig
  )
  
  # --- 6. Compute Destination Metrics ---
  destinations_nodes <- intersect(igraph::V(g)$name, destinations_top)
  
  dest_deg <- igraph::degree(g, v = destinations_nodes)
  dest_betw <- igraph::betweenness(g, v = destinations_nodes)
  dest_eig_vector <- igraph::eigen_centrality(g, directed = FALSE)$vector
  dest_eig <- dest_eig_vector[match(destinations_nodes, names(dest_eig_vector))]
  
  destination_metrics <- tibble::tibble(
    destination = destinations_nodes,
    degree = dest_deg,
    betweenness = dest_betw,
    eigen_centrality = dest_eig
  )

# Create a data frame for nodes, including the calculated degree
nodes_df_all <- tibble::tibble(name = igraph::V(g)$name) |>
  dplyr::mutate(
    # Get the type property added in the original setup
    type = ifelse(name %in% donor_metrics$donor, 
                  "Donor", "Destination"),
    # Calculate degree for sizing and labeling
    degree = igraph::degree(g, v = name)
  )

# --- Prepare Node Data AND Compute Coordinates 
# Create the layout object first to get the coordinates (x, y)
layout_data <- ggraph::create_layout(g,
 layout = "fr") # Fruchterman-Reingold	General networks
# layout = "circle")
# layout = "kk")	#Kamada-Kawai	Small to medium networks 
# layout = "dr") #	Davidson-Harel	Finding a minimum-energy state; 

# Filter the layout data to only include the nodes of interest, 
# ensuring all necessary columns (x, y, name, type, degree) are present.
nodes_df_all_coords <- layout_data |>
  dplyr::as_tibble() |>
  dplyr::left_join(
    nodes_df_all |> dplyr::select(name, type, degree), 
    by = "name"
  ) |>
  dplyr::filter(!is.na(type)) # Filter out any non-donor/non-destination nodes 

# --- Ggraph Plot ---
plot <-  ggraph::ggraph(layout_data) + # Use the layout_data object here
    
      # EDGES: Use geom_edge_fan (works seamlessly with layout_data)
      ggraph::geom_edge_fan(ggplot2::aes(alpha = weight), 
                            alpha = 0.3, 
                            width = 0.5, 
                            show.legend = FALSE) +
    
      ggraph::geom_node_point(
        ggplot2::aes(color = nodes_df_all_coords$type[match(name, 
                                                        nodes_df_all_coords$name)],
                                  size = nodes_df_all_coords$degree[match(name,
                                                        nodes_df_all_coords$name)]),
                              alpha = 0.6) +
    
      # --- label ---
      ggrepel::geom_label_repel(
        data = nodes_df_all_coords, 
        ggplot2::aes(x = x, y = y, label = name, color = type), 
        inherit.aes = FALSE,
        size = 2.5,
        force = 2,
        max.overlaps = Inf,
        box.padding = 0.4,
        segment.color = 'grey80',
        show.legend = FALSE) +
      ggplot2::scale_size_continuous(range = c(2, 15), name = "Degree") +
      ggplot2::scale_color_manual(values = c("Donor" = "#007BFF",
                                             "Destination" = "#FFC300"), 
                                  name = "Node Type") +
    
      ggplot2::labs(
        title = paste0("Funding Network for ", recipient_name),
        subtitle = "Node size reflects Degree (number of destination).",
        caption = "Data Source: OCHA Financial Tracking Service (FTS) API. 
        Layout: Fruchterman-Reingold."
      ) +
      ggraph::theme_graph(
        background = "white",
        base_family = "sans"
      )
  
  
  # --- 7. Return Results ---
  result <- list(graph = g, 
                 donor_metrics = donor_metrics, 
                 destination_metrics = destination_metrics,
                 plot = plot)
  return(result)
}
