---
title: "flat_skeleton.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# clean_llm_response

  
```{r function-clean_llm_response}
#' Clean LLM Response
#'
#' Remove thinking tags, markdown, and other artifacts from LLM responses
#' Useful for Local Open Source Reasoning Small Language Model
#'
#' @param response Character string from LLM response
#' @param keep_punctuation boolean
#' @return Cleaned character string
#' @export
clean_llm_response <- function(response, keep_punctuation = TRUE) {
  if (!is.character(response)) return(response)
  
  # Split into lines
  lines <- strsplit(response, "\n")[[1]]
  
  # Find thinking tag boundaries
  think_start <- which(grepl("<think>", lines, ignore.case = TRUE))
  think_end <- which(grepl("</think>", lines, ignore.case = TRUE))
  
  # Remove ALL lines between thinking tags (inclusive)
  if (length(think_start) > 0 && length(think_end) > 0) {
    remove_indices <- integer(0)
    for (i in seq_along(think_start)) {
      if (think_start[i] <= think_end[i]) {
        remove_indices <- c(remove_indices, think_start[i]:think_end[i])
      }
    }
    if (length(remove_indices) > 0) {
      lines <- lines[-remove_indices]
    }
  }
  
  # Combine back
  response <- paste(lines, collapse = " ")
  
  # Remove all non-ASCII characters
  response <- gsub("[^\x20-\x7E]", "", response)
  
  # Remove common LLM artifacts and introductory phrases
  response <- gsub("^(Sure|Certainly|Okay|Here|First).*?(:|\\.)\\s*", "", response, ignore.case = TRUE)
  response <- gsub("^(As an AI|I am an AI|I'm a).*?\\.\\s*", "", response, ignore.case = TRUE)
  response <- gsub("^(My role includes|This includes).*?\\.\\s*", "", response, ignore.case = TRUE)
  response <- gsub("^(Aligning with constraints).*?\\.\\s*", "", response, ignore.case = TRUE)
  
  # Remove markdown formatting
  response <- gsub("\\*\\*|\\*|__|_", "", response)
  response <- gsub("\\[.*?\\]\\(.*?\\)", "", response)
  response <- gsub("#+\\s*", "", response)
  response <- gsub("`{1,3}", "", response)
  
  # Remove excessive whitespace
  response <- gsub("\\s+", " ", response)
  response <- trimws(response)
  
  # If empty after cleaning, provide fallback
  if (nchar(response) == 0) {
    return("Unable to generate story from this visualization.")
  }
  
  return(response)
}
```
  
```{r example-clean_llm_response}
response <- "<think>
First, I'm a humanitarian data visualization expert. My role includes extracting insights 
from visualizations, creating accessible narratives, highlighting patterns relevant to aid
efforts, using clear language with emotional resonance.
Aligning with constraints: Use plain language, be concise and impactful. Don't rehash 
every detail; build narrative depth around 2 key insights maximum in under 30 tokens.
</think>
This visualization tracks a relationship potentially critical for humanitarian logistics: 
higher fuel consumption versus increased weight. 车辆设计"
clean_llm_response(response)
```
  
```{r tests-clean_llm_response}
test_that("clean_llm_response works", {
  expect_true(inherits(clean_llm_response, "function")) 
})
```
  

# generate_plot_story

```{r function-generate_plot_story}
#' Generate Humanitarian Data Story from ggplot
#'
#' This function takes a ggplot2 object and generates a storytelling narrative
#' focused on humanitarian insights. It uses the \{ellmer\} package to call
#' a large or small language model from a supported provider.
#' 
#' If you do not have API keys or need to work offline, simply get ollama and 
#' look at top reasoning models - https://ollama.com/search?c=thinking 
#'
#' Setup:
#' 1. Install \{ellmer\}: `install.packages("ellmer")`
#' 2. Set your API key in your environment. For Azure OpenAI, use the standard
#'    OpenAI key variable:
#'    `Sys.setenv(OPENAI_API_KEY = "<YOUR_AZURE_OPENAI_KEY>")`
#' 3. When using Azure, set `provider = "azure"` and provide the env variables
#'   `Sys.setenv(AZURE_OPENAI_ENDPOINT = "<YOUR_AZURE_ENDPOINT>")`
#'   `Sys.setenv(AZURE_OPENAI_API_VERSION = "<YOUR_AZURE_OPENAI_API_VERSION>")`
#'   The best place to set this is in .Renviron, which you can easily edit by
#'    calling `usethis::edit_r_environ()`
#'
#' @param plot A `ggplot` object from ggplot2.
#' @param max_tokens Maximum number of tokens (approximate) 
#' for the narrative (default = 30).
#' @param provider Optional character string specifying the provider. Options 
#' include:
#'   `"openai"`, `"gemini"`, `"anthropic"`, `"ollama"`, `"azure"`. If `NULL`, 
#'   auto-detect from environment keys.
#' @param model Optional character string specifying the model name. For Azure,
#'    this is typically the deployment name. If `NULL`, a default model for the
#'    chosen provider will be used.
#' @param clean_response Logical. Whether to clean the response by removing
#'   thinking tags and other artifacts (default = TRUE).
#'
#' @return A character string containing a storytelling narrative focused on
#'  humanitarian data.
#'
#' @importFrom ggplot2 ggplot_build
#' @importFrom dplyr mutate_if
#' @importFrom utils capture.output head
#' @importFrom ellmer chat_openai chat_google_gemini chat_anthropic chat_ollama chat_azure_openai
#' @export
generate_plot_story <- function(plot, 
                                max_tokens = 30,
                                provider = NULL,
                                model = NULL,
                                clean_response = TRUE) {
  
  # Extract plot data (first layer) and truncate
  plot_data <- ggplot2::ggplot_build(plot)$data[[1]] |>
    dplyr::mutate_if(is.numeric, round, 2) |>
    head(30)
  plot_data_text <- capture.output(print(plot_data))
  
  # Extract title, subtitle, caption
  labels <- plot$labels
  title    <- if (!is.null(labels$title))    labels$title    else ""
  subtitle <- if (!is.null(labels$subtitle)) labels$subtitle else ""
  caption  <- if (!is.null(labels$caption))  labels$caption  else ""
  
  # Extract mapping aesthetics
  mapping_info <- if (!is.null(plot$mapping)) {
    mapping_text <- capture.output(print(plot$mapping))
    paste("Global mapping:", paste(mapping_text, collapse = " "))
  } else {
    "No global mapping defined"
  }

  # Extract layer-specific mappings
  layer_mappings <- sapply(plot$layers, function(layer) {
    if (!is.null(layer$mapping)) {
      paste("Layer mapping:", capture.output(print(layer$mapping)))
    } else {
      "No layer-specific mapping"
    }
  })
  layer_mappings_text <- paste(unique(layer_mappings), collapse = "; ")
  
  # Detect scales and transformations
  scale_info <- if (!is.null(plot$scales$scales) && length(plot$scales$scales) > 0) {
    scale_types <- sapply(plot$scales$scales, function(scale) {
      paste(class(scale)[1], "scale (", scale$aesthetics[1], ")")
    })
    paste("Scale transformations:", paste(unique(scale_types), collapse = ", "))
  } else {
    "No custom scale transformations detected"
  }
  
  # Detect geoms used
  geoms <- unique(sapply(plot$layers, function(layer) class(layer$geom)[1]))
  geoms_text <- paste(geoms, collapse = ", ")
  
  system_prompt <- paste0(
    "You are a humanitarian data analysis expert. Your role is to:\n",
    "1. Extract key humanitarian insights from a dataset and its visualization parameters\n",
    "2. Create compelling, accessible narratives tailored for an executive audiences\n",
    "3. Highlight patterns, trends, and implications for humanitarian response\n",
    "4. Adapt interpretation depth based on available data and context\n",
    "5. Use clear, plain language with appropriate emotional resonance\n\n",
    
    "CRITICAL INSTRUCTIONS:\n",
    "- DO NOT include any thinking tags like <think> or </think> in your response\n",
    "- DO NOT use markdown formatting, asterisks, or special characters\n",
    "- Provide ONLY the final narrative text\n",
    "- Your response should be clean plain text ready for display\n\n",
    
    "Response Guidelines:\n",
    "- Focus on the most significant patterns and their humanitarian relevance\n",
    "- Suggest potential implications or actions\n",
    "- Adjust the tone for an executive audience\n",
    "- Craft a clear narrative arc with a beginning (context/problem), middle (analysis/discovery), and end (insights/implications/call for actions)\n"
  )
  
  # Build enhanced prompt
  prompt <- paste0(
    "VISUALIZATION CONTEXT:\n",
    "Title: ", title, "\n",
    "Subtitle: ", subtitle, "\n", 
    "Caption: ", caption, "\n",
    "Chart type(s): ", geoms_text, "\n",
    "Data mappings: ", mapping_info, "\n",
    "Layer mappings: ", layer_mappings_text, "\n", 
    "Scales: ", scale_info, "\n\n",
    
    "DATA:\n", paste(plot_data_text, collapse = "\n"), "\n\n",
    
    "TASK: Create a humanitarian data story using the provided data and visualization parameters.\n",
    "Consider what each mapped variable represents and any data transformations applied.\n\n",
    
    "ADAPTIVE CONSTRAINTS:\n",
    "- Important! Maximum length for the generated output: ", max_tokens, " tokens\n",
    "- Prioritize clarity over completeness\n",
    "- Focus on 2-3 key insights if space is limited\n",
    "- Use concise but impactful language\n",
    "- IMPORTANT: Provide only clean text output without any thinking tags or markdown\n\n",
    
    "What humanitarian story does this data tell, considering the variable mappings and any data transformations?"
  )
  
  # Auto-detect provider if not specified
  if (is.null(provider)) {
    # Check for Azure-specific environment variables
    if (!is.na(Sys.getenv("AZURE_OPENAI_ENDPOINT", unset = NA_character_)) &&
        !is.na(Sys.getenv("AZURE_OPENAI_API_KEY", unset = NA_character_))) {
      provider <- "azure"
    } else if (!is.na(Sys.getenv("OPENAI_API_KEY", unset = NA_character_))) {
      provider <- "openai"
    } else if (!is.na(Sys.getenv("GEMINI_API_KEY", unset = NA_character_))) {
      provider <- "gemini"
    } else if (!is.na(Sys.getenv("ANTHROPIC_API_KEY", unset = NA_character_))) {
      provider <- "anthropic"
    } else {
      stop("No supported API key found. Set AZURE_OPENAI_ENDPOINT/KEY, OPENAI_API_KEY, GEMINI_API_KEY,
           ANTHROPIC_API_KEY, or install and set it to a local OLLAMA")
    }
  }
  
  provider <- tolower(provider)
  
  # Set default models if not provided
  if (is.null(model)) {
    model <- switch(
      provider,
      openai = "gpt-4o-mini",
      gemini = "gemini-2.5-flash",
      anthropic = "claude-3-5-sonnet-20241022",
      ollama = "deepseek-r1",
      azure = "gpt-4", # Placeholder: Must be a valid deployment name
      stop("Invalid provider specified. Choose from 
           'openai', 'gemini', 'anthropic', 'ollama', 'azure'.")
    )
  }
  
  # Initialize chat object
  chat <- switch(
    provider,
    openai = ellmer::chat_openai(model = model, system_prompt = system_prompt),
    
    # Azure OpenAI using the dedicated function and explicit environment variable checks
    azure = {
      # Fetch required environment variables
      azure_key <- Sys.getenv("AZURE_OPENAI_API_KEY")
      azure_endpoint <- Sys.getenv("AZURE_OPENAI_ENDPOINT")
      azure_version <- Sys.getenv("AZURE_OPENAI_API_VERSION")
      
      # VALIDATION: Check if any required variable is unset (returns "")
      if (azure_key == "" || azure_endpoint == "" || azure_version == "") {
        stop("For 'azure' provider, AZURE_OPENAI_API_KEY, AZURE_OPENAI_ENDPOINT, and AZURE_OPENAI_VERSION environment variables must all be set correctly in the R session.")
      }
      
      # Initialize chat object, passing the validated environment variables
      ellmer::chat_azure_openai(
        system_prompt = system_prompt,
        model = model,
        api_version = azure_version,
        endpoint = azure_endpoint,
        api_key = azure_key
      )
    },
    
    gemini = ellmer::chat_google_gemini(
      model = model,
      system_prompt = system_prompt,
      base_url = "https://generativelanguage.googleapis.com/v1beta/",
      api_key = Sys.getenv("GEMINI_API_KEY")),
    
    anthropic = ellmer::chat_anthropic(
      model = model, 
      system_prompt = system_prompt),
    
    ollama = ellmer::chat_ollama(
      model = model,
      system_prompt = system_prompt),
    
    stop(
      "Invalid provider specified. Choose from
         'openai', 'gemini', 'anthropic', 'ollama', 'azure'."
    )
  )
  
  # Send prompt and get response
  response <- chat$chat(prompt)
  
  # Clean response if requested
  if (clean_response) {
    response <- clean_llm_response(response)
  }
  
  return(response)
}

```
  
```{r example-generate_plot_story}

library(ggplot2)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) +
   geom_point() +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE) +
   labs(title = "Vehicle Efficiency",
        subtitle = "Fuel consumption vs weight",
        caption = "Source: mtcars dataset")

generate_plot_story(p, provider = "ollama", model = "deepseek-r1")

story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# To use as subtitle:
p + ggplot2::labs(subtitle = story)
```
  
```{r tests-generate_plot_story}
test_that("generate_plot_story works", {
  expect_true(inherits(generate_plot_story, "function")) 
})
```

# plot_donor_funding_over_time

```{r function-plot_donor_funding_over_time}
#' Plot Donor Funding Over Time
#'
#' Visualizes the total funding provided by a given donor across budget years.
#' Useful to track trends, identify peaks, and assess consistency.
#'
#' @param flows A dataframe of humanitarian funding flows (FTS format).
#' @param donor_name The name of the donor organization to filter.
#'
#' @return A ggplot object showing donor funding trends over budget years.
#' @importFrom ggplot2 ggplot aes geom_col geom_line geom_point labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_donor_funding_over_time <- function(flows, donor_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(sourceObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization",
                  sourceObjects_name == donor_name) |>
    dplyr::group_by(budgetYear) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE))
  
  ggplot2::ggplot(df, ggplot2::aes(x = as.integer(budgetYear), y = total_usd)) +
    ggplot2::geom_col(fill = "steelblue") +
    ggplot2::geom_line(group = 1, color = "darkred", size = 1) +
    ggplot2::geom_point(color = "darkred", size = 2) +
    ggplot2::labs(
      title = paste0("Funding Trends for Donor: ", donor_name),
      subtitle = "Total funding per budget year",
      x = "Budget Year",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}

```
  
```{r example-plot_donor_funding_over_time, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_donor_funding_over_time(flows, donor_name= "Spain, Government of")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
#cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
print(p + ggplot2::labs(subtitle = dubbed))

```

`r story`
  
```{r tests-plot_donor_funding_over_time}
test_that("plot_donor_funding_over_time works", {
  expect_true(inherits(plot_donor_funding_over_time, "function")) 
})
```

# plot_donor_earmarking

```{r function-plot_donor_earmarking}
#' Plot Donor Funding by Earmarking Type
#'
#' Visualizes the proportion of funding per earmarking type 
#' (Unearmarked, Softly earmarked, etc.)
#' for a selected donor. Helps understand donor flexibility and restrictions.
#'
#' @param flows A dataframe of humanitarian funding flows (FTS format).
#' @param donor_name Donor organization name to filter.
#'
#' @return A ggplot object showing donor funding by earmarking type.
#' @importFrom ggplot2 ggplot aes geom_col labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_donor_earmarking <- function(flows, donor_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(sourceObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization", 
                  sourceObjects_name == donor_name) |>
    tidyr::unnest(grandBargainEarmarkingType, names_repair = "unique") |>
    dplyr::group_by(grandBargainEarmarkingType) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE))
  
  ggplot2::ggplot(df, ggplot2::aes(x = grandBargainEarmarkingType, 
                                   y = total_usd)) +
    ggplot2::geom_col(fill = "dodgerblue") +
    ggplot2::labs(
      title = paste0("Funding by Earmarking Type for Donor: ", donor_name),
      subtitle = "Distribution of funding across earmarking types",
      x = "Earmarking Type",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_donor_earmarking, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_donor_earmarking(flows, donor_name= "Spain, Government of")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```
  
`r story`  
  
```{r tests-plot_donor_earmarking}
test_that("plot_donor_earmarking works", {
  expect_true(inherits(plot_donor_earmarking, "function")) 
})
```


# plot_donor_flowtype

```{r function-plot_donor_flowtype}
#' Plot Donor Flow Type Distribution
#'
#' Shows the distribution of flow types 
#' (Standard, Parked, Pass-through, Carryover)
#' for a selected donor. Useful for understanding donor engagement complexity.
#'
#' @param flows FTS flows dataframe.
#' @param donor_name Donor organization name.
#'
#' @return A ggplot object showing flow type proportions.
#' @importFrom ggplot2 ggplot aes geom_col labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_donor_flowtype <- function(flows, donor_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(sourceObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization",
                  sourceObjects_name == donor_name) |>
    dplyr::group_by(flowType) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE))
  
  ggplot2::ggplot(df, ggplot2::aes(x = flowType, y = total_usd)) +
    ggplot2::geom_col(fill = "purple") +
    ggplot2::labs(
      title = paste0("Flow Type Distribution for Donor: ", donor_name),
      subtitle = "Funding by flow type",
      x = "Flow Type",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_donor_flowtype, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_donor_flowtype(flows, donor_name= "Spain, Government of")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`

```{r tests-plot_donor_flowtype}
test_that("plot_donor_flowtype works", {
  expect_true(inherits(plot_donor_flowtype, "function")) 
})
```


# plot_donor_cluster_coverage

```{r function-plot_donor_cluster_coverage}
#' Plot Donor Cluster Coverage
#'
#' Visualizes which humanitarian clusters each donor supports, using the number of
#' flows per cluster. Useful to understand donor focus and alignment with 
#' sector priorities.
#'
#' @param flows FTS flows dataframe.
#' @param donor_name Donor organization name.
#'
#' @return A ggplot object showing donor funding coverage across clusters.
#' @importFrom ggplot2 ggplot aes geom_col labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @importFrom stats reorder
#' @import unhcrthemes
#' @export
plot_donor_cluster_coverage <- function(flows, donor_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(sourceObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization", 
                  sourceObjects_name == donor_name) |>
    tidyr::unnest(destinationObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(destinationObjects_type %in% c( "GlobalCluster")) |>
    dplyr::rename(name = destinationObjects_name ) |>
    dplyr::group_by(name) |>
    dplyr::summarise(flows_per_cluster = dplyr::n()) |>
    dplyr::ungroup()
  
  ggplot2::ggplot(df, ggplot2::aes(x = reorder(factor(name), flows_per_cluster),
                                   y = flows_per_cluster)) +
    ggplot2::geom_col() +
    ggplot2::coord_flip()+
    ggplot2::labs(
      title = paste0("Cluster Coverage by Donor: ", donor_name),
      subtitle = "Number of flows per humanitarian cluster",
      x = "Cluster",
      y = "Number of Flows",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "X", axis = "X", axis_title = FALSE) 
}
```
  
```{r example-plot_donor_cluster_coverage, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_donor_cluster_coverage(flows, donor_name= "Spain, Government of")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_donor_cluster_coverage}
test_that("plot_donor_cluster_coverage works", {
  expect_true(inherits(plot_donor_cluster_coverage, "function")) 
})
```

# plot_recipient_funding_composition

```{r function-plot_recipient_funding_composition}
#' Plot Recipient Funding Composition by Donor
#'
#' Shows how a specific recipient organization’s funding is distributed across 
#' donors.
#' Useful for assessing donor diversification and reliance.
#'
#' @param flows A dataframe of humanitarian funding flows (FTS format).
#' @param recipient_name The name of the recipient organization to filter.
#'
#' @return A ggplot object showing donor shares of recipient funding.
#' @importFrom ggplot2 ggplot aes geom_col coord_flip labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_recipient_funding_composition <- function(flows, recipient_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(destinationObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(destinationObjects_type == "Organization", 
                  destinationObjects_name == recipient_name) |>
    tidyr::unnest(sourceObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::group_by(sourceObjects_name) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE))
  
  ggplot2::ggplot(df, ggplot2::aes(x = reorder(sourceObjects_name, total_usd),
                                   y = total_usd)) +
    ggplot2::geom_col(fill = "forestgreen") +
    ggplot2::coord_flip() +
    ggplot2::labs(
      title = paste0("Funding Composition for Recipient: ", recipient_name),
      subtitle = "Funding received by donor organization",
      x = "Donor",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "X", axis = "X", axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_recipient_funding_composition, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_recipient_funding_composition(flows, 
              recipient_name = "United Nations High Commissioner for Refugees")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_recipient_funding_composition}
test_that("plot_recipient_funding_composition works", {
  expect_true(inherits(plot_recipient_funding_composition, "function")) 
})
```

# plot_recipient_grandbargain

```{r function-plot_recipient_grandbargain}
#' Plot Grand Bargain Earmarking by Recipient
#'
#' Visualizes the proportion of funding earmarked under the Grand Bargain 
#' commitments for each recipient. Helps to assess how much funding aligns 
#' with international humanitarian reform commitments.
#'
#' @param flows FTS flows dataframe.
#' @param recipient_name Recipient organization name.
#'
#' @return A ggplot object showing the split of earmarked vs non-earmarked 
#' funding.
#' @importFrom ggplot2 ggplot aes geom_col labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_recipient_grandbargain <- function(flows, recipient_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(destinationObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(destinationObjects_type == "Organization", 
                  destinationObjects_name == recipient_name) |>
    tidyr::unnest(grandBargainEarmarkingType, names_repair = "unique") |>
    dplyr::group_by(grandBargainEarmarkingType) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE)) |>
    dplyr::mutate(grandBargainEarmarkingType = factor(grandBargainEarmarkingType,
        levels= c("unearmarked", "softly earmarked", 
                  "earmarked", "tightly earmarked")))
  
  ggplot2::ggplot(df, ggplot2::aes(x = grandBargainEarmarkingType, 
                                   y = total_usd)) +
    ggplot2::geom_col() +
    ggplot2::coord_flip() +
    ggplot2::scale_y_continuous(
      labels = scales::label_number(scale_cut = scales::cut_short_scale())
    ) +
    ggplot2::labs(
      title = paste0("Recipient Grand Bargain Earmarking for ", recipient_name),
      subtitle = "Distribution of earmarked vs non-earmarked funding",
      x = "Earmarking Type",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "X", axis = "X", axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_recipient_grandbargain, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_recipient_grandbargain(flows,
          recipient_name = "United Nations High Commissioner for Refugees")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_recipient_grandbargain}
test_that("plot_recipient_grandbargain works", {
  expect_true(inherits(plot_recipient_grandbargain, "function")) 
})
```
  
# plot_recipient_cofunding

```{r function-plot_recipient_cofunding}
#' Plot Recipient Co-Funding Rate
#'
#' Shows how often a recipient shares funding with other recipients for 
#' a given donor.
#' Useful to see multi-recipient funding trends.
#'
#' @param flows A dataframe of FTS funding flows.
#' @param recipient_name Recipient organization name to filter.
#'
#' @return A ggplot object with co-funding rates.
#' @importFrom ggplot2 ggplot aes geom_col coord_flip labs  scale_y_continuous
#' @importFrom dplyr filter group_by summarise n_distinct mutate
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_recipient_cofunding <- function(flows, recipient_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(destinationObjects, names_repair = "unique", names_sep = "_") |>
    dplyr::filter(destinationObjects_type == "Organization", 
                  destinationObjects_name == recipient_name) |>
    dplyr::group_by(id) |>
    dplyr::summarise(recipient_count = dplyr::n_distinct(destinationObjects_name),
                     .groups = "drop") |>
    dplyr::mutate(shared = recipient_count > 1)
  
  cofunding_rate <- mean(df$shared, na.rm = TRUE)
  
  ggplot2::ggplot(data.frame(shared = c(cofunding_rate, 1 - cofunding_rate),
                             category = c("Shared", "Sole")), 
                  ggplot2::aes(x = category, y = shared)) +
    ggplot2::geom_col() +
    ggplot2::coord_flip() +
    ggplot2::labs(
      title = paste0("Co-Funding Rate for Recipient: ", recipient_name),
      subtitle = "Proportion of multi-recipient funding",
      x = "",
      y = "Proportion",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "X", axis = "X", axis_title = FALSE) 
}
```
  
```{r example-plot_recipient_cofunding, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_recipient_cofunding(flows, 
              recipient_name = "United Nations High Commissioner for Refugees")


# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_recipient_cofunding}
test_that("plot_recipient_cofunding works", {
  expect_true(inherits(plot_recipient_cofunding, "function")) 
})
```

# plot_recipient_contribution_type

```{r function-plot_recipient_contribution_type}
#' Plot Recipient Funding by Contribution Type
#'
#' Visualizes the split of funding received by a recipient based on 
#' contribution type
#' (e.g., financial or in-kind). Useful to assess funding modality diversity.
#'
#' @param flows FTS flows dataframe.
#' @param recipient_name Recipient organization name.
#'
#' @return A ggplot object showing funding by contribution type.
#' @importFrom ggplot2 ggplot aes geom_col labs  scale_y_continuous
#' @importFrom dplyr filter group_by summarise n_distinct mutate
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_recipient_contribution_type <- function(flows, recipient_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(destinationObjects, 
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(destinationObjects_type == "Organization",
                  destinationObjects_name == recipient_name) |>
    dplyr::group_by(contributionType) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE))
  
  ggplot2::ggplot(df, ggplot2::aes(x = contributionType, y = total_usd)) +
    ggplot2::geom_col() +
    ggplot2::coord_flip() +
    ggplot2::labs(
      title = paste0("Funding by Contribution Type for Recipient: ",
                     recipient_name),
      subtitle = "Distribution of financial vs in-kind contributions",
      x = "Contribution Type",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_recipient_contribution_type, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_recipient_contribution_type(flows, 
                recipient_name = "United Nations High Commissioner for Refugees")


# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_recipient_contribution_type}
test_that("plot_recipient_contribution_type works", {
  expect_true(inherits(plot_recipient_contribution_type, "function")) 
})
```

# plot_destination_funding_destination

```{r function-plot_destination_funding_destination, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
#' Plot Funding by Destination Location
#'
#' Visualizes total humanitarian funding directed to a given destination destination.
#' Useful to identify funding hotspots and compare regions.
#'
#' @param flows A dataframe of humanitarian funding flows (FTS format).
#' @param destination_name The name of the destination location to filter.
#'
#' @return A ggplot object showing total funding per donor for the destination.
#' @importFrom ggplot2 ggplot aes geom_col coord_flip labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_destination_funding_destination <- function(flows, destination_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(destinationObjects,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(destinationObjects_type == "Location",
                  destinationObjects_name == destination_name) |>
    tidyr::unnest(sourceObjects,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::group_by(sourceObjects_name) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE))
  
  ggplot2::ggplot(df, ggplot2::aes(x = reorder(sourceObjects_name, total_usd),
                                   y = total_usd)) +
    ggplot2::geom_col(fill = "darkorange") +
    ggplot2::coord_flip() +
    ggplot2::labs(
      title = paste0("Funding Origin for ", destination_name),
      subtitle = "Funding contributed by each donor",
      x = "Donor",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "X",
                             axis = "Y",
                             axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_destination_funding_destination, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_destination_funding_destination(flows, destination_name= "Burundi")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_destination_funding_destination}
test_that("plot_destination_funding_destination works", {
  expect_true(inherits(plot_destination_funding_destination, "function")) 
})
```

# plot_destination_funding_donor

```{r function-plot_destination_funding_donor}
#' Plot Destination Funding by Donor
#'
#' Shows funding received at a destination from multiple donors.
#' Useful to identify funding hotspots or dependency.
#'
#' @param flows FTS flows dataframe.
#' @param destination_name Destination location name.
#'
#' @return A ggplot object showing total funding per donor for the destination.
#' @importFrom ggplot2 ggplot aes geom_col coord_flip labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @importFrom tidyr unnest
#' @import unhcrthemes
#' @export
plot_destination_funding_donor <- function(flows, destination_name) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    tidyr::unnest(destinationObjects,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(destinationObjects_type == "Location",
                  destinationObjects_name == destination_name) |>
    tidyr::unnest(sourceObjects,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::group_by(sourceObjects_name) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE))
  
  ggplot2::ggplot(df, ggplot2::aes(x = reorder(sourceObjects_name, total_usd),
                                   y = total_usd)) +
    ggplot2::geom_col(fill = "darkorange") +
    ggplot2::coord_flip() +
    ggplot2::labs(
      title = paste0("Funding for Destination: ", destination_name),
      subtitle = "Funding contributed by each donor",
      x = "Donor",
      y = "Funding (USD)",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "X",
                             axis = "Y",
                             axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_destination_funding_donor, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_destination_funding_donor(flows, destination_name= "Burundi")

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_destination_funding_donor}
test_that("plot_destination_funding_donor works", {
  expect_true(inherits(plot_destination_funding_donor, "function")) 
})
```

# plot_destination_heatmap

```{r function-plot_destination_heatmap}
#' Plot Top Donors Heatmap
#'
#' Visualizes the total funding from top donors to recipient organizations
#' for a given destination.
#'
#' @param flows FTS flows dataframe
#' @param destination_name Name of the destination location to filter for
#' @param top_n Number of top donors to display (default = 5)
#'
#' @return A ggplot heatmap
#' @importFrom dplyr filter mutate group_by summarise slice_max ungroup select rename inner_join
#' @importFrom tidyr unnest
#' @importFrom stringi stri_enc_toutf8
#' @importFrom purrr map map_df
#' @export
plot_destination_heatmap <- function(flows, destination_name, top_n = 5) {
   flows <- filter_flows_for_indicators(flows)
  # ---- STEP 1: Expand nested destination objects ----
  dest_expanded <- flows |>
    dplyr::mutate(destinationObjects2 = destinationObjects) |>
    tidyr::unnest(destinationObjects,
                  names_repair = "unique",
                  names_sep = "_")
  
  # ---- STEP 2: Filter for destination (case-insensitive) ----
  flows_loc <- dest_expanded |>
    dplyr::filter(
      destinationObjects_type == "Location",
      tolower(destinationObjects_name) == tolower(destination_name)
    )
  
  if (nrow(flows_loc) == 0) {
    warning(paste("No flows found for destination:", destination_name))
    return(
      ggplot2::ggplot() +
        ggplot2::labs(title = paste("No data for", destination_name))
    )
  }
  
  # ---- STEP 3: Expand donor and recipient orgs ----
  donors_recipient_expanded <- flows_loc |>
    tidyr::unnest(sourceObjects,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    tidyr::unnest(destinationObjects2,
                  names_repair = "unique",
                  names_sep = "_") |>
    dplyr::filter(destinationObjects2_type == "Organization")
  
  # ---- STEP 4: Aggregate donor → recipient totals ----
  flow_data <- donors_recipient_expanded  |>
    dplyr::mutate(
      donor = stringi::stri_enc_toutf8(sourceObjects_name),
      recipient = stringi::stri_enc_toutf8(destinationObjects2_name)
    ) |>
    dplyr::group_by(donor, recipient) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE), .groups = "drop")
  
  if (nrow(flow_data) == 0) {
    warning("No Donor to Recipient organization flows for this destination.")
    return(ggplot2::ggplot() + ggplot2::labs(title = "No organization-level data"))
  }
  
  # ---- STEP 5: Select Top N donors ----
  top_donors <- flow_data |>
    dplyr::group_by(donor) |>
    dplyr::summarise(total = sum(total_usd), .groups = "drop") |>
    dplyr::slice_max(total, n = top_n)
  
  df_plot <- top_donors |>
    dplyr::inner_join(flow_data, by = "donor") |>
    dplyr::mutate(
      donor = stringr::str_wrap(donor, width = 40),
      recipient = stringr::str_wrap(recipient, width = 40)
    )
  
  # ---- STEP 6: Plot ----
  p <- ggplot2::ggplot(
    df_plot,
    ggplot2::aes(y = recipient, x = donor, fill = total_usd)
  ) +
    
    ggplot2::geom_tile(color = "white", linewidth = 0.3) +
    
    ggplot2::geom_text(
      ggplot2::aes(
        label = scales::label_number(
          scale_cut = scales::cut_short_scale(),
          accuracy = 0.1
        )(total_usd),
        color = total_usd
      ),
      size = 3.5, fontface = "bold"
    ) +
    
    ggplot2::scale_fill_viridis_c(
      option = "plasma",
      na.value = "grey85",
      labels = scales::label_number(accuracy = 0.1),
      name = "Funding (USD)"
    ) +
    
    ggplot2::scale_color_gradient(
      guide = "none",
      high= "black",
      low  = "white"
    ) +
    
    unhcrthemes::theme_unhcr(
      grid = TRUE,
      axis = FALSE,
      legend = FALSE,
      axis_title = FALSE
    ) +
    
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)
    ) +
    
    ggplot2::labs(
      title = paste0("Top ", top_n, " Donors to Recipients for ", destination_name),
      subtitle = "Organization-level flows extracted from FTS nested structures",
      x = "Recipient Organization",
      y = "Donor Organization",
      caption = "Source: UN OCHA FTS API"
    )
  
  return(p)
}
```
  
```{r example-plot_destination_heatmap, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_destination_heatmap(flows, destination_name= "Burundi", top_n = 5)

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_destination_heatmap}
test_that("plot_destination_heatmap works", {
  expect_true(inherits(plot_destination_heatmap, "function")) 
})
```



# plot_funding_status_timeline

```{r function-plot_funding_status_timeline}
#' Plot Funding Timeline by Status
#'
#' Shows the evolution of funding amounts by status (pledge, commitment, paid)
#' across budget years. Useful for tracking donor disbursement progress.
#'
#' @param flows FTS flows dataframe.
#'
#' @return A ggplot object showing funding over time by status.
#' @importFrom ggplot2 ggplot aes geom_line geom_point labs  scale_y_continuous
#' @importFrom dplyr  filter group_by summarise
#' @import unhcrthemes
#' @export
plot_funding_status_timeline <- function(flows) {
   flows <- filter_flows_for_indicators(flows)
  df <- flows |>
    dplyr::group_by(budgetYear, status) |>
    dplyr::summarise(total_usd = sum(amountUSD, na.rm = TRUE), .groups = "drop")
  
  ggplot2::ggplot(df, ggplot2::aes(x = as.integer(budgetYear), 
                                   y = total_usd, 
                                   color = status)) +
    ggplot2::geom_line(size = 1) +
    ggplot2::geom_point(size = 2) +
    ggplot2::labs(
      title = "Funding Timeline by Status",
      subtitle = "Evolution of pledge, commitment, and paid funding",
      x = "Budget Year",
      y = "Funding (USD)",
      color = "Status",
      caption = "Source: OCHA Finantial Tracking Service (Flow API)"
    ) +
    unhcrthemes::theme_unhcr(grid = "Y", axis = "X", axis_title = FALSE) +
    ggplot2::scale_y_continuous(labels = scales::comma)
}
```
  
```{r example-plot_funding_status_timeline, fig.retina = 2, fig.width = 8, fig.asp = 0.618, fig.align = "center", out.width = "90%"}
p <- plot_funding_status_timeline(flows)

# getting LLm story
story <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini", max_tokens = 300)
# cat(story)
# and plot with more powerful subtitle
dubbed <- generate_plot_story(p, provider = "azure", model = "gpt-4.1-mini")
p + ggplot2::labs(subtitle = dubbed)
```

`r story`
  
```{r tests-plot_funding_status_timeline}
test_that("plot_funding_status_timeline works", {
  expect_true(inherits(plot_funding_status_timeline, "function")) 
})
```


# generate_report
     
  
```{r function-generate_report}
#' Generate Quarto HTML / PDF Country Factsheets in Batch
#'
#' This function renders the 'Country_Factsheet' Quarto template for a list of
#' countries, generating a report file for each.
#'
#' @param type either donor recipient or destination.
#' @param name name of  donor recipient or destination if NULL batch process them
#'
#' @importFrom dplyr filter select pull
#' @importFrom quarto quarto_render
#' @importFrom here here
#'
#' @return nothing, reports are generated in the specified folder.
#'
#' @export
generate_report <- function(type="donor",
                            name=NULL) {
  
  template_path = system.file(paste0("_extension/", type,"/template.qmd"), 
                                package = "ftsAnalysis")
  ## Create the outfolder if it does not exist
  folder <- "docs/reports"
  output_dir <- here::here(folder)
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
    message("Created output directory: ", output_dir)
  }
  
  # Ensure template exists
  if (!file.exists(template_path)) {
    stop("Quarto template not found at: ", template_path, 
         ". Please check the template_path argument.")
  }
  
  flows <- filter_flows_for_indicators(flows)
  # --- Loop through each country for batch rendering ---
  if ( is.null(name)){
    if(type == "donor") {
      name <- flows |>
                tidyr::unnest(sourceObjects, names_repair = "unique", names_sep = "_") |>
                dplyr::filter(sourceObjects_type == "Organization") |>
                dplyr::pull(sourceObjects_name) |>
                unlist() |>
                unique()
      # dput(names(name))
      # dput(levles(factor(name$sourceObjects_type))
    }
  
    if(type == "recipient") {
      name <- flows |>
                tidyr::unnest(destinationObjects, names_repair = "unique", names_sep = "_") |>
                dplyr::filter(destinationObjects_type == "Organization") |>
                dplyr::pull(destinationObjects_name) |>
                unlist() |>
                unique()
    }
    
    
    if(type == "destination") {
      name <- flows |>
                tidyr::unnest(destinationObjects, names_repair = "unique", names_sep = "_") |>
                dplyr::filter(destinationObjects_type == "Location") |>
                dplyr::pull(destinationObjects_name) |>
                unlist() |>
                unique()
    }
  } 
  
  for ( this in name) {
    
    # 2. Define Output Filename and Path
    output_filename <- paste0('ftsAnalysis-', type, '-', this, '.html')
    output_filepath <- here::here(folder, output_filename)
    
    message("Rendering report for ", name,  "...")
    
    # 3. Render the Quarto document
    tryCatch({
      quarto::quarto_render(
        input = template_path,
        output_file = output_filepath,
        # Pass parameters to the YAML header and R code chunks
        execute_params = list(name = this )
      )
      message("Successfully generated: ", output_filename)
    }, error = function(e) {
      warning("Failed to render report for ", this, ": ", e$message)
    })
  }
}
```
  
```{r example-generate_report}
#generate_report(type = "donor")
```
  
```{r tests-generate_report}
test_that("generate_report works", {
  expect_true(inherits(generate_report, "function")) 
})
```
  


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_dev_5_visualisation.Rmd", vignette_name = "5-Visualisation")
```

