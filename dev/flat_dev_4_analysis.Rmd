---
title: "Analysis Documentation"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# analysis_systemic_network_density

  
```{r function-analysis_systemic_network_density}
#' Systemic: Network Density
#'
#' Calculates network density between donors and recipients as
#' the ratio of unique donor–recipient pairs to the maximum possible links.
#' 
#' Goal: Measures connectivity of the funding ecosystem:
#' number of unique links / maximum possible links.
#'
#' @param flows A dataframe including `sourceObjects`, `destinationObjects`.
#'
#' @return A tibble with one value: `Network_Density`.
#' @importFrom dplyr unnest filter summarise n_distinct rename
#' @export
analysis_systemic_network_density <- function(flows) {
  df <- flows %>%
    select(sourceObjects, destinationObjects) %>%
    unnest(sourceObjects, names_repair = "unique") %>%
    filter(sourceObjects.type == "Organization") %>%
    rename(donor = sourceObjects.name) %>%
    unnest(destinationObjects, names_repair = "unique") %>%
    filter(destinationObjects.type == "Organization") %>%
    rename(recipient = destinationObjects.name)
  
  n_donors <- n_distinct(df$donor)
  n_recipients <- n_distinct(df$recipient)
  n_links <- n_distinct(paste(df$donor, df$recipient))
  
  tibble(Network_Density = n_links / (n_donors * n_recipients))
}
```
  
```{r example-analysis_systemic_network_density}
analysis_systemic_network_density(flows)
```
  
```{r tests-analysis_systemic_network_density}
test_that("analysis_systemic_network_density works", {
  expect_true(inherits(analysis_systemic_network_density, "function")) 
})
```


# analysis_portfolio_scores
    

  
```{r function-analysis_portfolio_scores}
#' Compute Portfolio Scores for a Recipient
#'
#' Computes a portfolio score for each donor relative to a given recipient
#' using the formula:
#'
#' Portfolio_Score = SUM( Donor_engagement * 
#'                        Funding_amount * 
#'                        (1 - Donor_concentration_risk) *
#'                         Strategic_alignment )
#'
#' Where:
#' - Donor_engagement = fraction of years the donor funded the recipient (0–1)
#' - Funding_amount = sum(amountUSD) from donor → recipient
#' - Donor_concentration_risk = HHI of donor across destinations (0–1) 
#' [higher = more concentrated => more risk]
#' - Strategic_alignment = share of donor funding to the recipient's primary 
#' GlobalCluster (0–1) — best-effort derived
#'
#' Assumptions & notes:
#' - `recipient` is matched against `destinationObjects.name` 
#' (destination type "Location" or "Organization" or "Plan").
#' - strategic alignment is computed by comparing GlobalCluster names present in
#'  destinationObjects for the recipient vs donor.
#' - HHI is calculated per donor across all destination names (locations/plans).
#'
#' @param flows Dataframe `flows` as documented (must include sourceObjects, 
#' destinationObjects, amountUSD, budgetYear).
#' @param recipient Character scalar — recipient destination name to score 
#' donors for (match exactly).
#' @param top_n Optional integer — return only top N donors by portfolio score
#'  (default NULL = all).
#'
#' @return Tibble with columns: donor, donor_engagement, funding_amount, 
#' donor_concentration_risk, strategic_alignment, Portfolio_Score
#' @importFrom dplyr select filter group_by summarise mutate arrange desc left_join pull rename n_distinct
#' @importFrom tidyr unnest
#' @importFrom purrr map_chr
#' @importFrom stats na.omit
#' @export
analysis_portfolio_scores <- function(flows, recipient, top_n = NULL) {
  # prepare donors -> recipient flows
  df <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(destination = destinationObjects_name, destination_type = destinationObjects_type) |>
    dplyr::filter(destination_type %in% c("Location", "Organization", "Plan"))
  
  # donor -> recipient aggregated
  dr <- df |>
    dplyr::filter(destination == recipient) |>
    dplyr::group_by(donor) |>
    dplyr::summarise(
      funding_amount = sum(as.numeric(amountUSD), na.rm = TRUE),
      years_funded = dplyr::n_distinct(budgetYear[amountUSD > 0]),
      .groups = "drop"
    )
  
  # donor engagement (fraction of years donor active in dataset that include recipient)
  donor_years <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(total_years = dplyr::n_distinct(budgetYear),
                     .groups = "drop")
  
  dr <- dr |>
    dplyr::left_join(donor_years, by = "donor") |>
    dplyr::mutate(donor_engagement = ifelse(total_years > 0, years_funded / total_years, 0))
  
  # donor concentration risk (HHI across destinations for each donor)
  donor_hhi <- df |>
    dplyr::group_by(donor, destination) |>
    dplyr::summarise(total = sum(as.numeric(amountUSD), na.rm = TRUE),
                     .groups = "drop_last") |>
    dplyr::mutate(share = total / sum(total, na.rm = TRUE)) |>
    dplyr::summarise(HHI = sum(share^2, na.rm = TRUE), .groups = "drop")
  
  # normalize HHI to 0-1 (already 0-1) but ensure numeric
  donor_hhi <- donor_hhi |>
    dplyr::mutate(donor_concentration_risk = pmin(pmax(HHI, 0), 1)) |>
    dplyr::select(donor, donor_concentration_risk)
  
  # strategic alignment: best-effort — find top GlobalCluster (destinationObjects_type == "GlobalCluster") for recipient,
  # then compute share of donor funding to that cluster
  # extract recipient clusters
  recipient_clusters <- flows |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::filter(
      destinationObjects_name == recipient &
        destinationObjects_type %in% c("GlobalCluster", "Cluster")
    ) |>
    dplyr::pull(destinationObjects_name) |>
    unique()
  
  # compute donor->cluster shares
  if (length(recipient_clusters) == 0) {
    # fallback: set strategic_alignment to donor's share to recipient / donor total (i.e., relative focus)
    donor_total <- df |>
      dplyr::group_by(donor) |>
      dplyr::summarise(donor_total = sum(as.numeric(amountUSD), na.rm = TRUE),
                       .groups = "drop")
    
    dr <- dr |>
      dplyr::left_join(donor_total, by = "donor") |>
      dplyr::mutate(strategic_alignment = ifelse(donor_total > 0, funding_amount / donor_total, 0))
  } else {
    donor_cluster <- df |>
      dplyr::filter(destinationObjects_type %in% c("GlobalCluster", "Cluster")) |>
      dplyr::group_by(donor, destinationObjects_name) |>
      dplyr::summarise(total = sum(as.numeric(amountUSD), na.rm = TRUE),
                       .groups = "drop_last") |>
      dplyr::mutate(share = total / sum(total, na.rm = TRUE)) |>
      dplyr::filter(destinationObjects_name %in% recipient_clusters) |>
      dplyr::group_by(donor) |>
      dplyr::summarise(strategic_alignment = sum(share, na.rm = TRUE),
                       .groups = "drop")
    
    dr <- dr |>
      dplyr::left_join(donor_cluster, by = "donor") |>
      dplyr::mutate(strategic_alignment = ifelse(is.na(strategic_alignment), 0, strategic_alignment))
  }
  
  res <- dr |>
    dplyr::left_join(donor_hhi, by = "donor") |>
    dplyr::mutate(
      donor_concentration_risk = ifelse(
        is.na(donor_concentration_risk),
        0,
        donor_concentration_risk
      ),
      Portfolio_Score = donor_engagement * funding_amount * (1 - donor_concentration_risk) * strategic_alignment
    ) |>
    dplyr::arrange(dplyr::desc(Portfolio_Score))
  
  if (!is.null(top_n))
    res <- res |> dplyr::slice_head(n = top_n)
  return(res)
}
```
  
```{r example-analysis_portfolio_scores}
analysis_portfolio_scores(flows, 
               recipient="United Nations High Commissioner for Refugees", 
                          top_n = 10)
```
  
```{r tests-analysis_portfolio_scores}
test_that("analysis_portfolio_scores works", {
  expect_true(inherits(analysis_portfolio_scores, "function")) 
})
```
  
# analysis_prepare_opportunity_dataset

```{r function-analysis_prepare_opportunity_dataset}
#' Prepare Funding Opportunity Dataset
#'
#' Aggregates flows into donor–recipient–year observations and prepares features
#' for an opportunity prediction model. Features include:
#'  - donor funding cycle timing (mean decision month)
#'  - historical funding patterns (growth in recent years)
#'  - simple NLP signals from description/keywords (presence of crisis keywords)
#'  - sector funding trends (share to global clusters)
#'
#' This function returns a tidy dataframe suitable for model training.
#'
#' @param flows Dataframe `flows`.
#' @param lookback_years Integer number of past years to compute trends (default 3).
#' @param crisis_keywords Character vector of keywords to flag global events (default common terms).
#'
#' @return A tibble of donor, recipient, year, and features.
#' @importFrom dplyr select mutate group_by summarise left_join arrange pull rename
#' @importFrom tidyr unnest
#' @importFrom lubridate ymd year month
#' @importFrom stringr str_detect str_to_lower
#' @export
analysis_prepare_opportunity_dataset <- function(
    flows,
    lookback_years = 3,
    crisis_keywords = c("flood", "drought", "earthquake", "conflict", "epidemic")) {
  
  # unnest donors/destinations
  df <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(recipient = destinationObjects_name, dest_type = destinationObjects_type) |>
    dplyr::filter(dest_type %in% c(
      "Location",
      "Organization",
      "Plan",
      "GlobalCluster",
      "Cluster"
    )) |>
    dplyr::mutate(
      amountUSD = as.numeric(amountUSD),
      decision_dt = suppressWarnings(lubridate::ymd_hms(decisionDate)),
      decision_dt = ifelse(
        is.na(decision_dt),
        suppressWarnings(lubridate::ymd(decisionDate)),
        decision_dt
      )
    ) |>
    dplyr::mutate(decision_month = as.integer(lubridate::month(decision_dt)),
                  year = as.integer(budgetYear))
  
  # basic per donor-recipient-year features
  base <- df |>
    dplyr::group_by(donor, recipient, year) |>
    dplyr::summarise(
      total_amount = sum(amountUSD, na.rm = TRUE),
      n_flows = dplyr::n(),
      avg_decision_month = mean(decision_month, na.rm = TRUE),
      crisis_flag = mean(
        stringr::str_detect(
          stringr::str_to_lower(description),
          paste(crisis_keywords, collapse = "|")
        ),
        na.rm = TRUE
      ),
      .groups = "drop"
    )
  
  # compute recent growth (percent change) using lookback_years
  growth <- base |>
    dplyr::group_by(donor, recipient) |>
    dplyr::arrange(year) |>
    dplyr::mutate(
      lag_amount = dplyr::lag(total_amount, lookback_years),
      pct_growth = ifelse(
        !is.na(lag_amount) &
          lag_amount > 0,
        (total_amount - lag_amount) / lag_amount,
        NA_real_
      )
    ) |>
    dplyr::ungroup()
  
  # sector trends: share to GlobalCluster if available in destinationObjects
  cluster_share <- df |>
    dplyr::filter(dest_type %in% c("GlobalCluster", "Cluster")) |>
    dplyr::group_by(donor, recipient, year, destinationObjects_name) |>
    dplyr::summarise(cluster_amount = sum(amountUSD, na.rm = TRUE),
                     .groups = "drop") |>
    dplyr::group_by(donor, recipient, year) |>
    dplyr::mutate(cluster_share = cluster_amount / sum(cluster_amount, na.rm = TRUE)) |>
    dplyr::summarise(max_cluster_share = max(cluster_share, na.rm = TRUE),
                     .groups = "drop")
  
  res <- growth |>
    dplyr::left_join(cluster_share, by = c("donor", "recipient", "year"))
  
  return(res)
}
```
  
```{r example-analysis_prepare_opportunity_dataset}
analysis_prepare_opportunity_dataset( flows,
    lookback_years = 3,
    crisis_keywords = c("flood", "drought", 
                        "earthquake", "conflict", "epidemic")
)
```
  
```{r tests-analysis_prepare_opportunity_dataset}
test_that("analysis_prepare_opportunity_dataset works", {
  expect_true(inherits(analysis_prepare_opportunity_dataset, "function")) 
})
```
  
# analysis_fit_opportunity_model

```{r function-analysis_fit_opportunity_model}
#' Fit a simple Funding Opportunity Model (logistic)
#'
#' Fits a logistic regression to predict whether a donor will fund a recipient
#' in year t+1 based on features prepared by `prepare_opportunity_dataset()`.
#'
#' Label construction: response = 1 if total_amount > 0 in year t+1 for same donor–recipient.
#'
#' @param features Dataframe produced by analysis_prepare_opportunity_dataset().
#' @param min_year Minimum year to use for training (filters older data).
#'
#' @return A glm object (binomial) and the training frame (list with components model, data).
#' @importFrom dplyr group_by arrange lead left_join
#' @export
analysis_fit_opportunity_model <- function(features, min_year = NULL) {
  df <- features
  if (!is.null(min_year))
    df <- df |> dplyr::filter(year >= min_year)
  
  # create response: whether there is funding next year
  next_year <- df |>
    dplyr::select(donor, recipient, year, total_amount) |>
    dplyr::rename(total_next = total_amount) |>
    dplyr::mutate(year = year - 1)
  
  train <- df |>
    dplyr::left_join(next_year, by = c("donor", "recipient", "year")) |>
    dplyr::mutate(opportunity = ifelse(!is.na(total_next) &
                                         total_next > 0, 1, 0)) |>
    dplyr::select(
      donor,
      recipient,
      year,
      opportunity,
      total_amount,
      pct_growth,
      avg_decision_month,
      crisis_flag,
      max_cluster_share
    )
  
  # drop rows with missing predictors
  train <- train |> stats::na.omit()
  
  if (nrow(train) < 50) {
    warning("Fewer than 50 training rows — model may be unstable.")
  }
  
  # fit a simple logistic model
  model <- stats::glm(
    opportunity ~ total_amount + pct_growth + avg_decision_month + crisis_flag + max_cluster_share,
    data = train,
    family = stats::binomial(link = "logit")
  )
  
  return(list(model = model, train = train))
}
```
  
```{r example-analysis_fit_opportunity_model}
analysis_fit_opportunity_model(features, min_year = NULL)
```
  
```{r tests-analysis_fit_opportunity_model}
test_that("analysis_fit_opportunity_model works", {
  expect_true(inherits(analysis_fit_opportunity_model, "function")) 
})
```
  
  
# analysis_competitive_intel_matrix

  
```{r function-analysis_competitive_intel_matrix}
#' Competitive Intelligence Matrix
#'
#' Computes our organization's competitive position across sectors using:
#'  - Market_share = Our_funding_in_sector / Total_sector_funding
#'  - Growth_differential = Our_growth - Average_peer_growth
#'  - Funding_diversity = 1 - HHI(our_funding_sources)
#'  - Peer_encroachment = sum(peer_growth_in_our_core_sectors)
#'
#' @param flows Dataframe `flows`.
#' @param our_org Character name of our organization as appears
#'  in destinationObjects.name (type Organization).
#' @param peers Optional character vector of peer organization names. 
#' If NULL peers are all other organizations in destinationObjects.
#' @param sector_level Destination cluster type to use for 
#'                   sectors: "GlobalCluster"
#'
#' @return Tibble with sector-level and aggregated competitive indicators
#'  and a composite Competitive_Position score.
#' @importFrom dplyr filter group_by summarise left_join mutate arrange desc n_distinct pull
#' @importFrom tidyr unnest
#' @export
analysis_competitive_intel_matrix <- function(flows,
                                              our_org,
                                              peers = NULL,
                                              sector_level = "GlobalCluster") {
  df <- flows |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::filter(destinationObjects_type %in% c("Organization", sector_level)) |>
    dplyr::rename(dest_name = destinationObjects_name, dest_type = destinationObjects_type)
  
  # Identify sectors per flow. We'll treat rows with dest_type == sector_level as sector labels.
  # Build flow-level table mapping sector (if present) to flow. If no sector present, NA.
  # Create a combined view with source donor info
  df2 <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(destination = destinationObjects_name, dest_type = destinationObjects_type) |>
    dplyr::mutate(amountUSD = as.numeric(amountUSD))
  
  # derive sector column: prefer GlobalCluster/Cluster entries (destinationObjects_type)
  df2 <- df2 |>
    dplyr::mutate(sector = ifelse(
      dest_type %in% c("GlobalCluster", "Cluster"),
      destination,
      NA_character_
    ))
  
  # propagate sector across rows by grouping on id (flows may contain multiple destinationObjects; best-effort)
  # For simplicity aggregate by donor, destination (organization) and sector where sector not NA
  sector_flows <- df2 |>
    dplyr::filter(!is.na(sector)) |>
    dplyr::group_by(sector) |>
    dplyr::summarise(total_sector = sum(amountUSD, na.rm = TRUE),
                     .groups = "drop")
  
  # our funding by sector
  our_sector <- df2 |>
    dplyr::filter(destination == our_org & !is.na(sector)) |>
    dplyr::group_by(sector) |>
    dplyr::summarise(our_funding = sum(amountUSD, na.rm = TRUE),
                     .groups = "drop")
  
  # peers: all orgs except our_org if peers NULL
  if (is.null(peers)) {
    peers <- df2 |> dplyr::pull(destination) |> unique()
    peers <- setdiff(peers, our_org)
  }
  
  # peer growth: compute year-over-year growth in sector funding for peers
  peer_growth <- df2 |>
    dplyr::filter(destination %in% peers & !is.na(sector)) |>
    dplyr::group_by(sector, year = as.integer(budgetYear), destination) |>
    dplyr::summarise(amount = sum(amountUSD, na.rm = TRUE),
                     .groups = "drop") |>
    dplyr::group_by(sector, destination) |>
    dplyr::arrange(year) |>
    dplyr::mutate(lag = dplyr::lag(amount),
                  growth = ifelse(!is.na(lag) &
                                    lag > 0, (amount - lag) / lag, NA_real_)) |>
    dplyr::group_by(sector) |>
    dplyr::summarise(peer_avg_growth = mean(growth, na.rm = TRUE),
                     .groups = "drop")
  
  # our_growth per sector
  our_growth <- df2 |>
    dplyr::filter(destination == our_org & !is.na(sector)) |>
    dplyr::group_by(sector, year = as.integer(budgetYear)) |>
    dplyr::summarise(amount = sum(amountUSD, na.rm = TRUE),
                     .groups = "drop") |>
    dplyr::group_by(sector) |>
    dplyr::arrange(year) |>
    dplyr::mutate(lag = dplyr::lag(amount),
                  growth = ifelse(!is.na(lag) &
                                    lag > 0, (amount - lag) / lag, NA_real_)) |>
    dplyr::summarise(our_avg_growth = mean(growth, na.rm = TRUE),
                     .groups = "drop")
  
  # compute market share, growth differential, diversity (HHI) and peer encroachment
  # market share
  market <- sector_flows |>
    dplyr::left_join(our_sector, by = "sector") |>
    dplyr::left_join(our_growth, by = "sector") |>
    dplyr::left_join(peer_growth, by = "sector") |>
    dplyr::mutate(
      our_funding = ifelse(is.na(our_funding), 0, our_funding),
      market_share = ifelse(total_sector > 0, our_funding / total_sector, NA_real_),
      growth_differential = our_avg_growth - peer_avg_growth
    )
  
  # funding diversity for our org: HHI across donors funding our_org
  donors_to_our <- df2 |>
    dplyr::filter(destination == our_org) |>
    dplyr::group_by(donor) |>
    dplyr::summarise(total = sum(amountUSD, na.rm = TRUE),
                     .groups = "drop") |>
    dplyr::mutate(share = total / sum(total, na.rm = TRUE))
  our_hhi <- sum((donors_to_our$share)^2, na.rm = TRUE)
  funding_diversity = 1 - our_hhi
  
  # peer encroachment: sum of peer_avg_growth in our core sectors (where our_funding > median)
  core_sectors <- market |> dplyr::filter(our_funding > median(our_funding, na.rm = TRUE)) |> dplyr::pull(sector)
  peer_encroachment <- market |> dplyr::filter(sector %in% core_sectors) |> dplyr::summarise(sum_peer_growth = sum(peer_avg_growth, na.rm = TRUE)) |> dplyr::pull(sum_peer_growth)
  
  # assemble
  market <- market |>
    dplyr::mutate(
      funding_diversity = funding_diversity,
      peer_encroachment = peer_encroachment,
      Competitive_Position = market_share + growth_differential + funding_diversity - (peer_encroachment / (length(core_sectors) + 1))
    )
  
  return(market)
}
```
  
```{r example-analysis_competitive_intel_matrix}
analysis_competitive_intel_matrix(flows,
                                              our_org,
                                              peers = NULL,
                                              sector_level = "GlobalCluster")
```
  
```{r tests-analysis_competitive_intel_matrix}
test_that("analysis_competitive_intel_matrix works", {
  expect_true(inherits(analysis_competitive_intel_matrix, "function")) 
})
```

# analysis_donor_lifecycle_stage

  
```{r function-analysis_donor_lifecycle_stage}
#' Donor Lifecycle Stage Scoring
#'
#' Assigns donors to lifecycle stages:
#'  1) Prospect (alignment > 0.7, no funding)
#'  2) New Partner (1-2 years funding)
#'  3) Growing Partner (increasing amounts, multiple sectors)
#'  4) Strategic Partner (multi-year, flexible funding)
#'  5) Legacy Partner (10+ years, co-design initiatives)
#'
#' Uses flows to compute engagement_frequency, funding_trend (slope), multiyear_share proxy, and partnership_complexity proxy.
#'
#' @param flows Dataframe `flows`.
#' @param alignment_df Optional tibble with donor alignment scores (donor, alignment_score 0-1). If NULL alignment is computed as donor share to recipient sectors (best-effort).
#'
#' @return Tibble with donor, metrics and stage (factor).
#' @importFrom dplyr select group_by summarise mutate arrange desc left_join n_distinct
#' @importFrom tidyr unnest
#' @importFrom stats lm coef
#' @export
analysis_donor_lifecycle_stage <- function(flows, alignment_df = NULL) {
  df <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(destination = destinationObjects_name, dest_type = destinationObjects_type) |>
    dplyr::mutate(amountUSD = as.numeric(amountUSD))
  
  # engagement frequency = years with any funding
  engagement <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(years = dplyr::n_distinct(budgetYear), total_amount = sum(amountUSD, na.rm = TRUE), .groups = "drop")
  
  # funding trend: slope of amount per year (aggregate)
  trend <- df |>
    dplyr::group_by(donor, year = as.integer(budgetYear)) |>
    dplyr::summarise(year_amount = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
    dplyr::group_by(donor) |>
    dplyr::summarise(funding_trend = tryCatch({
      fit <- stats::lm(year_amount ~ year)
      coef(fit)[["year"]]
    }, error = function(e) NA_real_), .groups = "drop")
  
  # multiyear_share proxy: flows with flowType == "Parked" or parentFlowId present → assume multiyear
  multi <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(multiyear_share = sum(ifelse(flowType %in% c("Parked"), as.numeric(amountUSD), 0), na.rm = TRUE) / sum(as.numeric(amountUSD), na.rm = TRUE), .groups = "drop")
  
  # partnership_complexity proxy: number of distinct destination types or sectors engaged
  complexity <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(partnership_complexity = dplyr::n_distinct(destination), .groups = "drop")
  
  res <- engagement |>
    dplyr::left_join(trend, by = "donor") |>
    dplyr::left_join(multi, by = "donor") |>
    dplyr::left_join(complexity, by = "donor")
  
  # alignment: if provided, merge; otherwise set 0.5 default
  if (!is.null(alignment_df)) res <- res |> dplyr::left_join(alignment_df, by = "donor") else res <- res |> dplyr::mutate(alignment_score = 0.5)
  
  # stage rules (heuristic)
  res <- res |>
    dplyr::mutate(
      stage = dplyr::case_when(
        alignment_score > 0.7 & total_amount == 0 ~ "Prospect",
        years <= 2 & total_amount > 0 ~ "New Partner",
        funding_trend > 0 & partnership_complexity > 3 ~ "Growing Partner",
        multiyear_share >= 0.2 & alignment_score >= 0.6 ~ "Strategic Partner",
        years >= 10 ~ "Legacy Partner",
        TRUE ~ "Maintenance"
      )
    )
  res$stage <- factor(res$stage, levels = c("Prospect", "New Partner", "Growing Partner", "Strategic Partner", "Legacy Partner", "Maintenance"))
  return(res)
}
```
  
```{r example-analysis_donor_lifecycle_stage}
analysis_donor_lifecycle_stage()
```
  
```{r tests-analysis_donor_lifecycle_stage}
test_that("analysis_donor_lifecycle_stage works", {
  expect_true(inherits(analysis_donor_lifecycle_stage, "function")) 
})
```
  
# analysis_donor_segmentation

  
```{r function-analysis_donor_segmentation}
#' Donor Segmentation (Priority Matrix)
#'
#' Classify donors into priority segments:
#'  - Strategic Stars (High priority, under-resourced)
#'  - Core Partners (High priority, well-resourced)
#'  - Emerging Opportunities (Medium priority, growth potential)
#'  - Maintenance Accounts (Low priority, stable)
#'  - Divestment Candidates (Low priority, declining)
#'
#' Uses Engagement_Index, Alignment_Index, Growth_Potential computed from flows.
#'
#' @param flows Dataframe `flows`.
#' @param our_org Character name of our org (to compute "under-resourced" signals).
#'
#' @return Tibble with donor and assigned segment plus Resource_Allocation_Score.
#' @importFrom dplyr select group_by summarise mutate left_join
#' @export
analysis_donor_segmentation <- function(flows, our_org) {
  # compute engagement index (years funded normalized), alignment proxy (share to our_org sectors), growth potential (trend)
  df <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(destination = destinationObjects_name, dest_type = destinationObjects_type) |>
    dplyr::mutate(amountUSD = as.numeric(amountUSD))
  
  engagement <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(years = dplyr::n_distinct(budgetYear), total = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
    dplyr::mutate(engagement_index = scales::rescale(years, to = c(0,1)))
  
  # alignment proxy: fraction of donor funding into destinations where our_org also works (same destination names)
  our_dests <- df |>
    dplyr::filter(destination == our_org) |>
    dplyr::pull(destination) %>% unique()
  # If our_org doesn't appear as a destination, fallback to sectors not implemented — set mid alignment
  if (length(our_dests) == 0) {
    alignment_df <- engagement |> dplyr::mutate(alignment_index = 0.5)
  } else {
    donor_to_our <- df |>
      dplyr::group_by(donor) |>
      dplyr::summarise(our_overlap = sum(amountUSD[destination %in% our_dests], na.rm = TRUE), donor_total = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
      dplyr::mutate(alignment_index = ifelse(donor_total>0, our_overlap / donor_total, 0))
    alignment_df <- donor_to_our |> dplyr::select(donor, alignment_index)
  }
  
  # growth potential: slope of funding over years
  trend <- df |>
    dplyr::group_by(donor, year = as.integer(budgetYear)) |>
    dplyr::summarise(amt = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
    dplyr::group_by(donor) |>
    dplyr::summarise(growth = tryCatch({coef(lm(amt ~ year))["year"]}, error = function(e) NA_real_), .groups = "drop") |>
    dplyr::mutate(growth_potential = scales::rescale(growth, to = c(0,1)))
  
  seg <- engagement |>
    dplyr::left_join(alignment_df, by = "donor") |>
    dplyr::left_join(trend, by = "donor") |>
    dplyr::mutate(
      alignment_index = ifelse(is.na(alignment_index), 0.5, alignment_index),
      growth_potential = ifelse(is.na(growth_potential), 0, growth_potential),
      Strategic_Priority = engagement_index * alignment_index * growth_potential,
      Resource_Allocation_Score = Strategic_Priority / (1 + total)  # normalize by current spend to identify under-resourced
    ) |>
    dplyr::mutate(
      segment = dplyr::case_when(
        Strategic_Priority >= quantile(Strategic_Priority, 0.9, na.rm = TRUE) & Resource_Allocation_Score > quantile(Resource_Allocation_Score, 0.5, na.rm = TRUE) ~ "Strategic Stars",
        Strategic_Priority >= quantile(Strategic_Priority, 0.7, na.rm = TRUE) ~ "Core Partners",
        Strategic_Priority >= quantile(Strategic_Priority, 0.4, na.rm = TRUE) ~ "Emerging Opportunities",
        Strategic_Priority < quantile(Strategic_Priority, 0.4, na.rm = TRUE) & total > median(total, na.rm = TRUE) ~ "Maintenance Accounts",
        TRUE ~ "Divestment Candidates"
      )
    )
  return(seg)
}
```
  
```{r example-analysis_donor_segmentation}
analysis_donor_segmentation()
```
  
```{r tests-analysis_donor_segmentation}
test_that("analysis_donor_segmentation works", {
  expect_true(inherits(analysis_donor_segmentation, "function")) 
})
```
  
# analysis_funding_forecast
    

  
```{r function-analysis_funding_forecast}
#' Funding Forecast (ARIMA)
#'
#' Aggregate historical amounts by month and forecast future funding for a donor or recipient.
#'
#' @param flows Dataframe `flows`.
#' @param by Character: "donor" or "recipient" (which entity to forecast for).
#' @param name Character: name of donor or recipient to forecast.
#' @param h Integer: months to forecast ahead (default 12).
#'
#' @return A list with components: ts (monthly ts), model (fitted ARIMA), forecast (forecast object)
#' @importFrom tidyr unnest
#' @importFrom dplyr filter mutate group_by summarise arrange
#' @importFrom lubridate ymd floor_date
#' @importFrom forecast auto.arima forecast
#' @export
analysis_funding_forecast <- function(flows, by = c("donor", "recipient"), name, h = 12) {
  by <- match.arg(by)
  
  df <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::rename(donor = sourceObjects_name, donor_type = sourceObjects_type)
  
  df <- df |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(recipient = destinationObjects_name, dest_type = destinationObjects_type) |>
    dplyr::mutate(amountUSD = as.numeric(amountUSD))
  
  if (by == "donor") {
    sel <- df |>
      dplyr::filter(donor == name)
    if (nrow(sel) == 0) stop("No flows found for donor ", name)
    sel <- sel |>
      dplyr::mutate(dt = suppressWarnings(lubridate::ymd_hms(date)),
                    dt = ifelse(is.na(dt), suppressWarnings(lubridate::ymd(date)), dt),
                    month = as.Date(lubridate::floor_date(dt, unit = "month"))) |>
      dplyr::group_by(month) |>
      dplyr::summarise(amount = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
      dplyr::arrange(month)
  } else {
    sel <- df |>
      dplyr::filter(recipient == name)
    if (nrow(sel) == 0) stop("No flows found for recipient ", name)
    sel <- sel |>
      dplyr::mutate(dt = suppressWarnings(lubridate::ymd_hms(date)),
                    dt = ifelse(is.na(dt), suppressWarnings(lubridate::ymd(date)), dt),
                    month = as.Date(lubridate::floor_date(dt, unit = "month"))) |>
      dplyr::group_by(month) |>
      dplyr::summarise(amount = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
      dplyr::arrange(month)
  }
  
  # ensure continuous monthly series
  if (nrow(sel) < 2) stop("Not enough monthly observations to build a forecast.")
  ts_start <- c(as.integer(format(min(sel$month), "%Y")), as.integer(format(min(sel$month), "%m")))
  ts_vec <- stats::ts(sel$amount, start = ts_start, frequency = 12)
  
  fit <- forecast::auto.arima(ts_vec)
  fcast <- forecast::forecast(fit, h = h)
  
  return(list(ts = ts_vec, model = fit, forecast = fcast))
}
```
  
```{r example-analysis_funding_forecast}
analysis_funding_forecast()
```
  
```{r tests-analysis_funding_forecast}
test_that("analysis_funding_forecast works", {
  expect_true(inherits(analysis_funding_forecast, "function")) 
})
```
  
# analysis_donor_network_metrics
    

  
```{r function-analysis_donor_network_metrics}
#' Donor–Recipient Network Metrics
#'
#' Build a bipartite donor → recipient network from flows and compute node centrality measures:
#' - donor_degree, donor_betweenness, donor_eigenvector (via igraph)
#'
#' @param flows Dataframe `flows`.
#' @param top_n Optional integer: restrict network to top_n donors by amount and top_n recipients by amount for readability.
#'
#' @return A list with components: graph (igraph object), donor_metrics (tibble), recipient_metrics (tibble)
#' @importFrom tidyr unnest
#' @importFrom dplyr group_by summarise arrange desc slice_head pull mutate
#' @importFrom igraph graph_from_data_frame degree betweenness eigen_centrality
#' @export
analysis__donor_network_metrics <- function(flows, top_n = 50) {
  df <- flows |>
    tidyr::unnest(sourceObjects, names_sep = "_") |>
    dplyr::filter(sourceObjects_type == "Organization") |>
    dplyr::rename(donor = sourceObjects_name) |>
    tidyr::unnest(destinationObjects, names_sep = "_") |>
    dplyr::rename(recipient = destinationObjects_name, dest_type = destinationObjects_type) |>
    dplyr::filter(dest_type %in% c("Organization", "Location", "Plan")) |>
    dplyr::mutate(amountUSD = as.numeric(amountUSD))
  
  donors_top <- df |>
    dplyr::group_by(donor) |>
    dplyr::summarise(total = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(total)) |>
    dplyr::slice_head(n = top_n) |>
    dplyr::pull(donor)
  
  recipients_top <- df |>
    dplyr::group_by(recipient) |>
    dplyr::summarise(total = sum(amountUSD, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(total)) |>
    dplyr::slice_head(n = top_n) |>
    dplyr::pull(recipient)
  
  edges <- df |>
    dplyr::filter(donor %in% donors_top, recipient %in% recipients_top) |>
    dplyr::group_by(donor, recipient) |>
    dplyr::summarise(weight = sum(amountUSD, na.rm = TRUE), .groups = "drop")
  
  # build bipartite graph
  g <- igraph::graph_from_data_frame(edges, directed = FALSE)
  
  # donor metrics
  donors_nodes <- intersect(igraph::V(g)$name, donors_top)
  donor_deg <- igraph::degree(g, v = donors_nodes)
  donor_betw <- igraph::betweenness(g, v = donors_nodes)
  donor_eig <- igraph::eigen_centrality(g, directed = FALSE)$vector[match(donors_nodes, igraph::V(g)$name)]
  
  donor_metrics <- tibble::tibble(
    donor = donors_nodes,
    degree = donor_deg,
    betweenness = donor_betw,
    eigen_centrality = donor_eig
  )
  
  # recipient metrics
  recipients_nodes <- intersect(igraph::V(g)$name, recipients_top)
  rec_deg <- igraph::degree(g, v = recipients_nodes)
  rec_betw <- igraph::betweenness(g, v = recipients_nodes)
  rec_eig <- igraph::eigen_centrality(g, directed = FALSE)$vector[match(recipients_nodes, igraph::V(g)$name)]
  
  recipient_metrics <- tibble::tibble(
    recipient = recipients_nodes,
    degree = rec_deg,
    betweenness = rec_betw,
    eigen_centrality = rec_eig
  )
  
  return(list(graph = g, donor_metrics = donor_metrics, recipient_metrics = recipient_metrics))
}
```
  
```{r example-analysis_donor_network_metrics}
analysis_donor_network_metrics()
```
  
```{r tests-analysis_donor_network_metrics}
test_that("analysis_donor_network_metrics works", {
  expect_true(inherits(analysis_donor_network_metrics, "function")) 
})
```
    
<!--
# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly

#remotes::install_github("thinkr-open/checkhelper")
# checkhelper::print_globals()
fusen::inflate(flat_file = "dev/flat_dev_4_analysis", vignette_name = "4-Analysis")
```


